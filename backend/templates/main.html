<!DOCTYPE html>
<html>
<head>
  <title>Audio Stream</title>
  <!-- It's recommended to use the latest stable version of Socket.IO -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
</head>
<body>

  <h1>Audio Stream</h1>
  <button onclick="startStream()">Start talking</button>
  <button onclick="startConversation()">Socket connect</button>
  <button onclick="endConversation()">Socket disconnect</button>

  <div id="conversation">
    <h2>Conversation</h2>
    <!-- Messages will be appended here -->
  </div>

  <script>
    /***** Configuration Constants *****/
    const CONFIG = {
      SOCKET_URL: 'ws://localhost:8000/ws',
      AUDIO_SAMPLE_RATE: 8000,
      SCRIPT_PROCESSOR_BUFFER_SIZE: 256,
      INT16_NEGATIVE_MULTIPLIER: 0x8000, // 32768 for negative values
      INT16_POSITIVE_MULTIPLIER: 0x7FFF, // 32767 for positive values
      BIAS: 0x84,                      // 132
      CLIP: 32635
    };

    /***** Global Variables *****/
    let socket;
    let pendingAudioChunks = [];
    let audioQueue = [];
    let isPlaying = false;
    let audioContext = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: CONFIG.AUDIO_SAMPLE_RATE
    });

    /***** Form Submission Handler *****/
    document.getElementById('uploadForm').addEventListener('submit', function(event) {
      event.preventDefault(); // Prevent default form submission

      const formData = new FormData(this);
      fetch('/form', {
        method: 'POST',
        body: formData
      })
      .then(response => response.json())
      .then(data => {
        console.log('Form submitted successfully:', data);
      })
      .catch(error => {
        console.error('Error submitting form:', error);
      });
    });

    /***** Utility Functions *****/
    function generateId(length) {
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
      }
      return result;
    }

    function float32ToInt16(float32Array) {
      const int16Array = new Int16Array(float32Array.length);
      for (let i = 0; i < float32Array.length; i++) {
        const s = Math.max(-1, Math.min(1, float32Array[i]));
        int16Array[i] = s < 0
          ? s * CONFIG.INT16_NEGATIVE_MULTIPLIER
          : s * CONFIG.INT16_POSITIVE_MULTIPLIER;
      }
      return int16Array;
    }

    function int16ToMuLaw(int16Array) {
      const muLawArray = new Uint8Array(int16Array.length);
      for (let i = 0; i < int16Array.length; i++) {
        muLawArray[i] = linearToMuLawSample(int16Array[i]);
      }
      return muLawArray;
    }

    function linearToMuLawSample(sample) {
      // Clip the sample
      sample = Math.max(-CONFIG.CLIP, Math.min(CONFIG.CLIP, sample));

      // Determine sign and adjust sample if negative
      let sign = (sample < 0) ? 0x80 : 0;
      if (sign !== 0) {
        sample = -sample;
      }

      // Add bias and compute exponent and mantissa
      sample += CONFIG.BIAS;
      const exponent = getExponent(sample);
      const mantissa = (sample >> (exponent + 3)) & 0x0F;
      const muLawByte = ~(sign | (exponent << 4) | mantissa);
      return muLawByte;
    }

    function getExponent(sample) {
      let exponent = 7;
      for (let expMask = 0x4000; (sample & expMask) === 0 && exponent > 0; exponent--, expMask >>= 1);
      return exponent;
    }

    function muLawDecode(muLawByte) {
      muLawByte = ~muLawByte & 0xFF;
      const sign = (muLawByte & 0x80) ? -1 : 1;
      const exponent = (muLawByte & 0x70) >> 4;
      const mantissa = muLawByte & 0x0F;
      const magnitude = ((mantissa << 4) + 8) << exponent;
      return sign * magnitude;
    }

    /***** WebSocket Functions *****/
    function startConversation() {
      socket = new WebSocket(CONFIG.SOCKET_URL);

      socket.onopen = () => {
        // Send StartEvent conforming to the Pydantic model
        const startEvent = {
          event: 'start',
          start: {
            streamSid: generateId(32),
            accountSid: generateId(32),
            callSid: generateId(32)
          }
        };
        socket.send(JSON.stringify(startEvent));
      };

      socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        switch (data.event) {
          case 'result':
            handleResultEvent(data);
            break;
          case 'media':
            handleMediaEvent(data);
            break;
          case 'mark':
            handleMarkEvent(data);
            break;
          case 'clear':
            handleClearEvent();
            break;
          default:
            console.warn('Unknown event type:', data.event);
        }
      };

      socket.onclose = () => {
        console.log('Disconnected');
      };
    }

    function endConversation() {
      if (socket) {
        // Send ClosedEvent
        socket.send(JSON.stringify({ event: 'closed' }));
        socket.close();
        console.log('Disconnected');
      }
    }

    /***** Audio Functions *****/
    async function startStream() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log('Audio stream obtained:', stream);

        // Create a dedicated AudioContext for this stream
        const localAudioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: CONFIG.AUDIO_SAMPLE_RATE
        });
        console.log('AudioContext sample rate:', localAudioContext.sampleRate);

        const source = localAudioContext.createMediaStreamSource(stream);
        const processor = localAudioContext.createScriptProcessor(
          CONFIG.SCRIPT_PROCESSOR_BUFFER_SIZE, 1, 1
        );

        source.connect(processor);
        processor.connect(localAudioContext.destination);

        processor.onaudioprocess = (e) => {
          const inputBuffer = e.inputBuffer.getChannelData(0);
          const int16Buffer = float32ToInt16(inputBuffer);
          const muLawBuffer = int16ToMuLaw(int16Buffer);
          const base64Buffer = btoa(String.fromCharCode.apply(null, muLawBuffer));

          // Send MediaEvent conforming to the Pydantic model
          const mediaEvent = {
            event: 'media',
            media: { payload: base64Buffer }
          };
          socket.send(JSON.stringify(mediaEvent));
        };
      } catch (err) {
        console.error('Error accessing audio stream:', err);
      }
    }

    function handleMediaEvent(data) {
      const encodedPayload = data.media.payload;
      // Decode base64 to Uint8Array (μ-law encoded bytes)
      const muLawBytes = Uint8Array.from(atob(encodedPayload), c => c.charCodeAt(0));

      // Decode μ-law bytes to PCM samples
      const pcmSamples = new Int16Array(muLawBytes.length);
      for (let i = 0; i < muLawBytes.length; i++) {
        pcmSamples[i] = muLawDecode(muLawBytes[i]);
      }

      // Normalize PCM samples to Float32Array in range [-1, 1]
      const float32Samples = new Float32Array(pcmSamples.length);
      for (let i = 0; i < pcmSamples.length; i++) {
        float32Samples[i] = pcmSamples[i] / 32768;
      }

      // Enqueue audio samples for playback
      audioQueue.push(float32Samples);
      pendingAudioChunks.push({ samples: float32Samples, markId: null });
    }

    function handleMarkEvent(data) {
      console.log("Received mark");
      const markId = data.mark.name;
      // Associate the markId with the first unmarked audio chunk
      const unmarkedChunk = pendingAudioChunks.find(chunk => chunk.markId === null);
      if (unmarkedChunk) {
        unmarkedChunk.markId = markId;
      }
      // Start playing if not already playing
      if (!isPlaying) {
        playNextAudio();
      }
    }

    function playNextAudio() {
      // Find the next chunk with an assigned markId
      const nextChunkIndex = pendingAudioChunks.findIndex(chunk => chunk.markId !== null);
      console.log("Playing next audio", nextChunkIndex);

      if (nextChunkIndex === -1) {
        isPlaying = false;
        return;
      }
      isPlaying = true;
      const chunk = pendingAudioChunks.splice(nextChunkIndex, 1)[0];

      playAudio(chunk.samples, () => {
        sendMarkEventToServer(chunk.markId);
        playNextAudio();
      });
    }

    function playAudio(float32Samples, callback) {
      console.log(`Playing audio chunk - ${float32Samples.length} samples`);
      const buffer = audioContext.createBuffer(1, float32Samples.length, CONFIG.AUDIO_SAMPLE_RATE);
      buffer.copyToChannel(float32Samples, 0);

      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(audioContext.destination);
      source.onended = callback;
      source.start(0);
    }

    function sendMarkEventToServer(markId) {
      // Send MarkEvent conforming to the Pydantic model (without extra properties)
      const markEvent = {
        event: 'mark',
        mark: { name: markId }
      };
      socket.send(JSON.stringify(markEvent));
    }

    function stopAudio() {
      // Clear pending audio chunks
      pendingAudioChunks = [];
      if (audioContext && audioContext.state !== 'closed') {
        audioContext.close().then(() => {
          audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: CONFIG.AUDIO_SAMPLE_RATE
          });
        });
      }
      isPlaying = false;
      console.log('Audio stopped');
    }

    /***** Incoming Result Event Handler *****/
    function handleResultEvent(data) {
      // data.result contains: stt_duration, llm_duration, tts_duration, total_duration, first_chunk_time, transcript, response
      const result = data.result;
      const p = document.createElement('p');
      p.innerHTML = `
        <span class="message-time">STT: ${result.stt_duration}ms</span>
        <span class="message-time">LLM: ${result.llm_duration}ms</span>
        <span class="message-time">TTS: ${result.tts_duration}ms</span>
        <span class="message-time">Total: ${result.total_duration}ms</span>
        <span class="message-time">First Chunk: ${result.first_chunk_time}ms</span>
        <strong>Transcript:</strong> ${result.transcript} <br>
        <strong>Response:</strong> ${result.response}
      `;
      p.id = "result-message";
      document.getElementById('conversation').appendChild(p);
    }

    function handleClearEvent() {
      sendMarksForRemainingChunks();
      stopAudio();
    }

    function sendMarksForRemainingChunks() {
      pendingAudioChunks.forEach(chunk => {
        if (chunk.markId !== null) {
          sendMarkEventToServer(chunk.markId);
        } else {
          const tempMarkId = generateId(10);
          chunk.markId = tempMarkId;
          sendMarkEventToServer(tempMarkId);
        }
      });
      pendingAudioChunks = [];
    }
  </script>
</body>


<head>
  <style>
    /* CSS remains unchanged */
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f9;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    h1 {
      color: #333;
    }

    #conversation {
      width: 80%;
      max-width: 600px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      padding: 20px;
      margin-top: 20px;
      height: 60vh;
    }

    #conversation h2 {
      margin-top: 0;
    }

    #conversation p {
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      display: flex;
      flex-direction: column;
    }

    .message-time {
      font-size: 0.8em;
      color: #888;
      margin-bottom: 5px;
      background-color: #e0e0e0;
      border-radius: 12px;
      padding: 2px 8px;
      display: inline-block;
    }

    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #0056b3;
    }
  </style>

</head>
</html>
